.venv/bin/py.test -f kinto_http/tests/ kinto_http/tests/functional.py
============================= test session starts ==============================
platform darwin -- Python 3.9.0, pytest-6.2.2, py-1.10.0, pluggy-1.0.0.dev0
rootdir: /Users/jeffryhidayat/Documents/kinto2/kinto-http.py
plugins: cov-2.11.1, xdist-2.2.1, forked-1.3.0
collected 333 items
collected 333 items

kinto_http/tests/functional.py FEFEFEFEFEFEFFEFEFEFEFEFFEFEFEFFEFEFEFEFE [  6%]
FEFEFFEFEFFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFE               [ 15%]
kinto_http/tests/test_batch.py .........                                 [ 18%]
kinto_http/tests/test_cli_utils.py .............                         [ 22%]
kinto_http/tests/test_client.py ........................................ [ 34%]
.....................................................................    [ 54%]
kinto_http/tests/test_endpoints.py ............                          [ 58%]
kinto_http/tests/test_exceptions.py .....                                [ 60%]
kinto_http/tests/test_logging.py ........................                [ 67%]
kinto_http/tests/test_replication.py .....                               [ 68%]
kinto_http/tests/test_session.py ....................................... [ 80%]
.                                                                        [ 80%]
kinto_http/tests/test_utils.py ............                              [ 84%]
kinto_http/tests/functional.py FEFEFEFEFEFEFFEFEFEFEFEFFEFEFEFFEFEFEFEFE [ 84%]
FEFEFFEFEFFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFE

==================================== ERRORS ====================================
___________ ERROR at teardown of FunctionalTest.test_bucket_creation ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_creation>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
____ ERROR at teardown of FunctionalTest.test_bucket_creation_if_not_exists ____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_creation_if_not_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_bucket_deletion ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
______ ERROR at teardown of FunctionalTest.test_bucket_deletion_if_exists ______

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_deletion_if_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________ ERROR at teardown of FunctionalTest.test_bucket_modification _________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_modification>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
__________ ERROR at teardown of FunctionalTest.test_bucket_retrieval ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_____________ ERROR at teardown of FunctionalTest.test_bucket_save _____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_save>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_bucket_sharing ____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_sharing>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
__________ ERROR at teardown of FunctionalTest.test_buckets_deletion ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_buckets_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_ ERROR at teardown of FunctionalTest.test_buckets_deletion_when_no_buckets_exist _

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_buckets_deletion_when_no_buckets_exist>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
__________ ERROR at teardown of FunctionalTest.test_buckets_retrieval __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_buckets_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________ ERROR at teardown of FunctionalTest.test_collection_creation _________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_creation>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
__ ERROR at teardown of FunctionalTest.test_collection_creation_if_not_exists __

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_creation_if_not_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________ ERROR at teardown of FunctionalTest.test_collection_deletion _________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
____ ERROR at teardown of FunctionalTest.test_collection_deletion_if_exists ____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_deletion_if_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_collection_list ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_list>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
________ ERROR at teardown of FunctionalTest.test_collection_not_found _________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_not_found>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________ ERROR at teardown of FunctionalTest.test_collection_sharing __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_sharing>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
________ ERROR at teardown of FunctionalTest.test_collections_deletion _________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collections_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_ ERROR at teardown of FunctionalTest.test_collections_deletion_when_no_collections_exist _

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collections_deletion_when_no_collections_exist>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_group_creation ____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_creation>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
____ ERROR at teardown of FunctionalTest.test_group_creation_if_not_exists _____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_creation_if_not_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_group_deletion ____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
______ ERROR at teardown of FunctionalTest.test_group_deletion_if_exists _______

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_deletion_if_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_____________ ERROR at teardown of FunctionalTest.test_group_list ______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_list>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
____________ ERROR at teardown of FunctionalTest.test_group_update _____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_update>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_groups_deletion ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_groups_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_ ERROR at teardown of FunctionalTest.test_groups_deletion_when_no_groups_exist _

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_groups_deletion_when_no_groups_exist>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
______ ERROR at teardown of FunctionalTest.test_multiple_record_deletion _______

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_multiple_record_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________ ERROR at teardown of FunctionalTest.test_one_record_deletion _________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_one_record_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_______ ERROR at teardown of FunctionalTest.test_patch_record_jsonpatch ________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_patch_record_jsonpatch>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
____ ERROR at teardown of FunctionalTest.test_record_creation_and_retrieval ____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_record_creation_and_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
______ ERROR at teardown of FunctionalTest.test_record_deletion_if_exists ______

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_record_deletion_if_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_record_sharing ____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_record_sharing>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_ ERROR at teardown of FunctionalTest.test_records_deletion_when_no_records_exist _

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_deletion_when_no_records_exist>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_____ ERROR at teardown of FunctionalTest.test_records_generator_retrieval _____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_generator_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_______ ERROR at teardown of FunctionalTest.test_records_list_retrieval ________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_list_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
__ ERROR at teardown of FunctionalTest.test_records_paginated_list_retrieval ___

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_paginated_list_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_____ ERROR at teardown of FunctionalTest.test_records_timestamp_retrieval _____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_timestamp_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_____________ ERROR at teardown of FunctionalTest.test_replication _____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_replication>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
------------------------------ Captured log call -------------------------------
ERROR    kinto_http.batch:batch.py:86 Batch #0: PUT /buckets/origin - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #1: PUT /buckets/origin/collections/coll - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #2: PUT /buckets/origin/collections/coll/records/7289550e-9ef6-4ae8-b9bf-4f76903d31e6 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #3: PUT /buckets/origin/collections/coll/records/14fa0403-87db-4298-8293-5bc54c4970d1 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #4: PUT /buckets/origin/collections/coll/records/3aa60efb-75a9-448f-a085-59f0147a92a7 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #5: PUT /buckets/origin/collections/coll/records/fd15ce30-7344-470f-b25b-7bd3ce0bd9f3 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #6: PUT /buckets/origin/collections/coll/records/455e62d8-a8a2-4b18-8d67-661d1c51e2bd - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #7: PUT /buckets/origin/collections/coll/records/41af9a36-dab6-42a3-a435-54672af5a845 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #8: PUT /buckets/origin/collections/coll/records/9ef832c3-3f00-4240-9d1b-9aa072d5059c - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #9: PUT /buckets/origin/collections/coll/records/b81cb07d-bc9a-4b44-9c6c-d59c36254658 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #10: PUT /buckets/origin/collections/coll/records/29a4f26c-4031-41b6-b77b-912f412af229 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #11: PUT /buckets/origin/collections/coll/records/0cce390b-3d67-44c1-9da3-37778661b567 - 404
__________ ERROR at teardown of FunctionalTest.test_request_batching ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_request_batching>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
------------------------------ Captured log call -------------------------------
ERROR    kinto_http.batch:batch.py:86 Batch #0: PUT /buckets/mozilla - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #1: PUT /buckets/mozilla/collections/fonts - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #2: PUT /buckets/mozilla/collections/fonts/records/70331747-5981-453b-9715-816ed87b2dc9 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #3: PUT /buckets/mozilla/collections/fonts/records/283ed09d-4666-4ba1-962b-90b59adb47d7 - 404
_____ ERROR at teardown of FunctionalTest.test_single_record_can_overwrite _____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_can_overwrite>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_ ERROR at teardown of FunctionalTest.test_single_record_creation_if_not_exists _

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_creation_if_not_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___ ERROR at teardown of FunctionalTest.test_single_record_doesnt_overwrite ____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_doesnt_overwrite>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________ ERROR at teardown of FunctionalTest.test_single_record_save __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_save>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
____ ERROR at teardown of FunctionalTest.test_updating_data_on_a_collection ____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_updating_data_on_a_collection>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
______ ERROR at teardown of FunctionalTest.test_updating_data_on_a_group _______

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_updating_data_on_a_group>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_bucket_creation ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_creation>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
____ ERROR at teardown of FunctionalTest.test_bucket_creation_if_not_exists ____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_creation_if_not_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_bucket_deletion ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
______ ERROR at teardown of FunctionalTest.test_bucket_deletion_if_exists ______

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_deletion_if_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________ ERROR at teardown of FunctionalTest.test_bucket_modification _________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_modification>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
__________ ERROR at teardown of FunctionalTest.test_bucket_retrieval ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_____________ ERROR at teardown of FunctionalTest.test_bucket_save _____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_save>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_bucket_sharing ____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_sharing>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
__________ ERROR at teardown of FunctionalTest.test_buckets_deletion ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_buckets_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_ ERROR at teardown of FunctionalTest.test_buckets_deletion_when_no_buckets_exist _

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_buckets_deletion_when_no_buckets_exist>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
__________ ERROR at teardown of FunctionalTest.test_buckets_retrieval __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_buckets_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________ ERROR at teardown of FunctionalTest.test_collection_creation _________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_creation>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
__ ERROR at teardown of FunctionalTest.test_collection_creation_if_not_exists __

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_creation_if_not_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________ ERROR at teardown of FunctionalTest.test_collection_deletion _________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
____ ERROR at teardown of FunctionalTest.test_collection_deletion_if_exists ____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_deletion_if_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_collection_list ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_list>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
________ ERROR at teardown of FunctionalTest.test_collection_not_found _________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_not_found>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________ ERROR at teardown of FunctionalTest.test_collection_sharing __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_sharing>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
________ ERROR at teardown of FunctionalTest.test_collections_deletion _________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collections_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_ ERROR at teardown of FunctionalTest.test_collections_deletion_when_no_collections_exist _

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collections_deletion_when_no_collections_exist>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_group_creation ____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_creation>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
____ ERROR at teardown of FunctionalTest.test_group_creation_if_not_exists _____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_creation_if_not_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_group_deletion ____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
______ ERROR at teardown of FunctionalTest.test_group_deletion_if_exists _______

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_deletion_if_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_____________ ERROR at teardown of FunctionalTest.test_group_list ______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_list>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
____________ ERROR at teardown of FunctionalTest.test_group_update _____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_update>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_groups_deletion ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_groups_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_ ERROR at teardown of FunctionalTest.test_groups_deletion_when_no_groups_exist _

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_groups_deletion_when_no_groups_exist>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
______ ERROR at teardown of FunctionalTest.test_multiple_record_deletion _______

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_multiple_record_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________ ERROR at teardown of FunctionalTest.test_one_record_deletion _________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_one_record_deletion>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_______ ERROR at teardown of FunctionalTest.test_patch_record_jsonpatch ________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_patch_record_jsonpatch>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
____ ERROR at teardown of FunctionalTest.test_record_creation_and_retrieval ____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_record_creation_and_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
______ ERROR at teardown of FunctionalTest.test_record_deletion_if_exists ______

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_record_deletion_if_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________ ERROR at teardown of FunctionalTest.test_record_sharing ____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_record_sharing>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_ ERROR at teardown of FunctionalTest.test_records_deletion_when_no_records_exist _

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_deletion_when_no_records_exist>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_____ ERROR at teardown of FunctionalTest.test_records_generator_retrieval _____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_generator_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_______ ERROR at teardown of FunctionalTest.test_records_list_retrieval ________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_list_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
__ ERROR at teardown of FunctionalTest.test_records_paginated_list_retrieval ___

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_paginated_list_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_____ ERROR at teardown of FunctionalTest.test_records_timestamp_retrieval _____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_timestamp_retrieval>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_____________ ERROR at teardown of FunctionalTest.test_replication _____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_replication>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
------------------------------ Captured log call -------------------------------
ERROR    kinto_http.batch:batch.py:86 Batch #0: PUT /buckets/origin - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #1: PUT /buckets/origin/collections/coll - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #2: PUT /buckets/origin/collections/coll/records/3f3adc05-d518-46a1-bcc6-c9702581e848 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #3: PUT /buckets/origin/collections/coll/records/dd188300-eb6a-4d13-a02d-1f758ba2411c - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #4: PUT /buckets/origin/collections/coll/records/75f531a7-c1db-47cd-b6ce-6096aa1ff61c - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #5: PUT /buckets/origin/collections/coll/records/69e65fcd-7fc5-4c69-b81b-692a01bcc23a - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #6: PUT /buckets/origin/collections/coll/records/48d58f1a-7677-45db-8140-e73867815660 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #7: PUT /buckets/origin/collections/coll/records/3b8b18fa-584c-45c9-b8c8-71e5373173f4 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #8: PUT /buckets/origin/collections/coll/records/6edcc7ac-bfd4-4599-b8bd-10bea13a1c00 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #9: PUT /buckets/origin/collections/coll/records/e975ef31-93b8-4ed2-adbe-52974d6d83bb - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #10: PUT /buckets/origin/collections/coll/records/55e68de1-3b5d-410a-92b9-c79188f705b0 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #11: PUT /buckets/origin/collections/coll/records/6454571c-40ff-40aa-9fd9-0202ccd517b0 - 404
__________ ERROR at teardown of FunctionalTest.test_request_batching ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_request_batching>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
------------------------------ Captured log call -------------------------------
ERROR    kinto_http.batch:batch.py:86 Batch #0: PUT /buckets/mozilla - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #1: PUT /buckets/mozilla/collections/fonts - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #2: PUT /buckets/mozilla/collections/fonts/records/622c7024-26ad-452e-aa5f-263de86f852f - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #3: PUT /buckets/mozilla/collections/fonts/records/76290638-44f2-4209-b090-27d88104cfb1 - 404
_____ ERROR at teardown of FunctionalTest.test_single_record_can_overwrite _____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_can_overwrite>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_ ERROR at teardown of FunctionalTest.test_single_record_creation_if_not_exists _

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_creation_if_not_exists>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___ ERROR at teardown of FunctionalTest.test_single_record_doesnt_overwrite ____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_doesnt_overwrite>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________ ERROR at teardown of FunctionalTest.test_single_record_save __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_save>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
____ ERROR at teardown of FunctionalTest.test_updating_data_on_a_collection ____

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_updating_data_on_a_collection>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
______ ERROR at teardown of FunctionalTest.test_updating_data_on_a_group _______

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_updating_data_on_a_group>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
=================================== FAILURES ===================================
_____________________ FunctionalTest.test_bucket_creation ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_creation>

    def test_bucket_creation(self):
>       bucket = self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8b01372e0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493759.72096
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________ FunctionalTest.test_bucket_creation_if_not_exists _______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_creation_if_not_exists>

    def test_bucket_creation_if_not_exists(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8b0127a00>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493760.285915
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_____________________ FunctionalTest.test_bucket_deletion ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_deletion>

    def test_bucket_deletion(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c85847f0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493760.813948
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
________________ FunctionalTest.test_bucket_deletion_if_exists _________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_deletion_if_exists>

    def test_bucket_deletion_if_exists(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d880ba30>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493761.325045
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
___________________ FunctionalTest.test_bucket_modification ____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_modification>

    def test_bucket_modification(self):
>       bucket = self.client.create_bucket(id="mozilla", data={"version": 1})

kinto_http/tests/functional.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c8595d00>, method = 'put'
endpoint = '/buckets/mozilla', data = {'version': 1}, permissions = None
payload = {'data': {'version': 1}}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{"data": {"version": 1}}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493761.8584461
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_____________________ FunctionalTest.test_bucket_retrieval _____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_retrieval>

    def test_bucket_retrieval(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d87e4700>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493762.372542
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_________ FunctionalTest.test_bucket_retrieval_fails_when_not_created __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_retrieval_fails_when_not_created>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_______________________ FunctionalTest.test_bucket_save ________________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_save>

    def test_bucket_save(self):
>       self.client.create_bucket(id="mozilla", permissions={"write": ["account:alexis"]})

kinto_http/tests/functional.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c8597550>, method = 'put'
endpoint = '/buckets/mozilla', data = None
permissions = {'write': ['account:alexis']}
payload = {'permissions': {'write': ['account:alexis']}}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{"permissions": {"write": ["account:alexis"]}}', 'headers': {'Content-Type': '...ion/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493763.3497322
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________________ FunctionalTest.test_bucket_sharing ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_sharing>

    def test_bucket_sharing(self):
        alice_credentials = ("alice", "p4ssw0rd")
>       alice_userid = self.get_user_id(alice_credentials)

kinto_http/tests/functional.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/tests/functional.py:57: in get_user_id
    r = self.create_user(credentials)
kinto_http/tests/functional.py:53: in create_user
    r.raise_for_status()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [400]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 400 Client Error: Bad Request for url: http://localhost:8888/v1/accounts/alice

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_____________________ FunctionalTest.test_buckets_deletion _____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_buckets_deletion>

    def test_buckets_deletion(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d86e5550>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493764.573437
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
__________ FunctionalTest.test_buckets_deletion_when_no_buckets_exist __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_buckets_deletion_when_no_buckets_exist>

    def test_buckets_deletion_when_no_buckets_exist(self):
>       deleted_buckets = self.client.delete_buckets()

kinto_http/tests/functional.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:398: in delete_buckets
    resp, _ = self.session.request("delete", endpoint, headers=headers)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d8705b50>, method = 'delete'
endpoint = '/buckets', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493765.072326
parsed = ParseResult(scheme='', netloc='', path='/buckets', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: DELETE /v1/buckets - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
____________________ FunctionalTest.test_buckets_retrieval _____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_buckets_retrieval>

    def test_buckets_retrieval(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d87d89a0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493765.571315
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_______________ FunctionalTest.test_collection_access_forbidden ________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_access_forbidden>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________________ FunctionalTest.test_collection_creation ____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_creation>

    def test_collection_creation(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:203: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d8705c70>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493766.587699
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
____________ FunctionalTest.test_collection_creation_if_not_exists _____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_creation_if_not_exists>

    def test_collection_creation_if_not_exists(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc89805b790>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493767.0928562
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
___________________ FunctionalTest.test_collection_deletion ____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_deletion>

    def test_collection_deletion(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d880e640>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493767.593793
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
________ FunctionalTest.test_collection_deletion_can_still_raise_errors ________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_deletion_can_still_raise_errors>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
______________ FunctionalTest.test_collection_deletion_if_exists _______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_deletion_if_exists>

    def test_collection_deletion_if_exists(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c858c5b0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493768.567553
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_____________________ FunctionalTest.test_collection_list ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_list>

    def test_collection_list(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8b01378b0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493769.067747
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
___________________ FunctionalTest.test_collection_not_found ___________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_not_found>

    def test_collection_not_found(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc89804dd30>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493769.569082
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
____________________ FunctionalTest.test_collection_sharing ____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_sharing>

    def test_collection_sharing(self):
        alice_credentials = ("alice", "p4ssw0rd")
>       alice_userid = self.get_user_id(alice_credentials)

kinto_http/tests/functional.py:456: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/tests/functional.py:57: in get_user_id
    r = self.create_user(credentials)
kinto_http/tests/functional.py:53: in create_user
    r.raise_for_status()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [400]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 400 Client Error: Bad Request for url: http://localhost:8888/v1/accounts/alice

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________________ FunctionalTest.test_collections_deletion ___________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collections_deletion>

    def test_collections_deletion(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c8584490>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493770.816149
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______ FunctionalTest.test_collections_deletion_when_no_collections_exist ______

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collections_deletion_when_no_collections_exist>

    def test_collections_deletion_when_no_collections_exist(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d87fdbb0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493771.315296
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________________ FunctionalTest.test_group_creation ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_creation>

    def test_group_creation(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d8852700>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493771.817837
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_________ FunctionalTest.test_group_creation_if_bucket_does_not_exist __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_creation_if_bucket_does_not_exist>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_______________ FunctionalTest.test_group_creation_if_not_exists _______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_creation_if_not_exists>

    def test_group_creation_if_not_exists(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc89804d430>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493772.7888288
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________________ FunctionalTest.test_group_deletion ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_deletion>

    def test_group_deletion(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c85b4460>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493773.279286
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
__________ FunctionalTest.test_group_deletion_can_still_raise_errors ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_deletion_can_still_raise_errors>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________________ FunctionalTest.test_group_deletion_if_exists _________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_deletion_if_exists>

    def test_group_deletion_if_exists(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d87f6970>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493774.263316
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
________________________ FunctionalTest.test_group_list ________________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_list>

    def test_group_list(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d87e1b20>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493774.766591
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_______________________ FunctionalTest.test_group_update _______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_update>

    def test_group_update(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d870c340>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493775.265076
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_____________________ FunctionalTest.test_groups_deletion ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_groups_deletion>

    def test_groups_deletion(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d8826b20>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493775.792384
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
___________ FunctionalTest.test_groups_deletion_when_no_groups_exist ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_groups_deletion_when_no_groups_exist>

    def test_groups_deletion_when_no_groups_exist(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d880bfd0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493776.298489
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_________________ FunctionalTest.test_multiple_record_deletion _________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_multiple_record_deletion>

    def test_multiple_record_deletion(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:410: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c8597eb0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493776.800575
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
___________________ FunctionalTest.test_one_record_deletion ____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_one_record_deletion>

    def test_one_record_deletion(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c8588460>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493777.297864
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
__________________ FunctionalTest.test_patch_record_jsonpatch __________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_patch_record_jsonpatch>

    def test_patch_record_jsonpatch(self):
>       self.client.create_bucket(id="b1")

kinto_http/tests/functional.py:504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d8794250>, method = 'put'
endpoint = '/buckets/b1', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493777.812475
parsed = ParseResult(scheme='', netloc='', path='/buckets/b1', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/b1'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/b1 - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________ FunctionalTest.test_record_creation_and_retrieval _______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_record_creation_and_retrieval>

    def test_record_creation_and_retrieval(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c8560c70>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493778.3166878
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
________________ FunctionalTest.test_record_deletion_if_exists _________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_record_deletion_if_exists>

    def test_record_deletion_if_exists(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:398: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d883d1f0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493778.818313
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________________ FunctionalTest.test_record_sharing ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_record_sharing>

    def test_record_sharing(self):
        alice_credentials = ("alice", "p4ssw0rd")
>       alice_userid = self.get_user_id(alice_credentials)

kinto_http/tests/functional.py:469: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/tests/functional.py:57: in get_user_id
    r = self.create_user(credentials)
kinto_http/tests/functional.py:53: in create_user
    r.raise_for_status()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [400]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 400 Client Error: Bad Request for url: http://localhost:8888/v1/accounts/alice

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
__________ FunctionalTest.test_records_deletion_when_no_records_exist __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_deletion_when_no_records_exist>

    def test_records_deletion_when_no_records_exist(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:420: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c8580280>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493780.043662
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_______________ FunctionalTest.test_records_generator_retrieval ________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_generator_retrieval>

    def test_records_generator_retrieval(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8980770d0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493780.541728
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
__________________ FunctionalTest.test_records_list_retrieval __________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_list_retrieval>

    def test_records_list_retrieval(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc89804dc40>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493781.074528
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_____________ FunctionalTest.test_records_paginated_list_retrieval _____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_paginated_list_retrieval>

    def test_records_paginated_list_retrieval(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c85aa820>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493781.578794
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_______________ FunctionalTest.test_records_timestamp_retrieval ________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_timestamp_retrieval>

    def test_records_timestamp_retrieval(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d86f9be0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493782.090383
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_______________________ FunctionalTest.test_replication ________________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_replication>

    def test_replication(self):
        # First, create a few records on the first kinto collection.
        with self.client.batch(bucket="origin", collection="coll") as batch:
            batch.create_bucket()
            batch.create_collection()
    
            for n in range(10):
>               batch.create_record(data={"foo": "bar", "n": n})

kinto_http/tests/functional.py:526: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/contextlib.py:124: in __exit__
    next(self.gen)
kinto_http/__init__.py:145: in batch
    batch_session.send()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.batch.BatchSession object at 0x7fc8d885ae80>

    def send(self):
        self._results = []
        _exceptions = []
        requests = self._build_requests()
        id_request = 0
        for chunk in utils.chunks(requests, self.batch_max_requests):
            kwargs = dict(
                method="POST", endpoint=self.endpoints.get("batch"), payload={"requests": chunk}
            )
            resp, headers = self.session.request(**kwargs)
            for i, response in enumerate(resp["responses"]):
                status_code = response["status"]
    
                level = logging.WARN if status_code < 400 else logging.ERROR
                message = response["body"].get("message", "")
                logger.log(
                    level,
                    "Batch #{}: {} {} - {} {}".format(
                        id_request, chunk[i]["method"], chunk[i]["path"], status_code, message
                    ),
                )
    
                # Full log in DEBUG mode
                logger.debug(
                    "\nBatch #{}: \n\tRequest: {}\n\tResponse: {}\n".format(
                        id_request, utils.json_dumps(chunk[i]), utils.json_dumps(response)
                    )
                )
    
                if not (200 <= status_code < 400):
                    # One of the server response is an error.
                    message = "{0} - {1}".format(status_code, response["body"])
                    exception = KintoException(message)
                    exception.request = RequestDict(chunk[i])
                    exception.response = ResponseDict(response)
                    # Should we ignore 4XX errors?
                    raise_on_4xx = status_code >= 400 and not self._ignore_4xx_errors
                    if raise_on_4xx:
                        _exceptions.append(exception)
                    if status_code >= 500:
                        raise exception
    
                id_request += 1
    
            self._results.append((resp, headers))
    
        if _exceptions:
>           raise KintoBatchException(_exceptions, self._results)
E           kinto_http.exceptions.KintoBatchException: PUT /buckets/origin - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}
E           PUT /buckets/origin/collections/coll - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}
E           PUT /buckets/origin/collections/coll/records/7289550e-9ef6-4ae8-b9bf-4f76903d31e6 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/14fa0403-87db-4298-8293-5bc54c4970d1 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/3aa60efb-75a9-448f-a085-59f0147a92a7 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/fd15ce30-7344-470f-b25b-7bd3ce0bd9f3 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/455e62d8-a8a2-4b18-8d67-661d1c51e2bd - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/41af9a36-dab6-42a3-a435-54672af5a845 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/9ef832c3-3f00-4240-9d1b-9aa072d5059c - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/b81cb07d-bc9a-4b44-9c6c-d59c36254658 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/29a4f26c-4031-41b6-b77b-912f412af229 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/0cce390b-3d67-44c1-9da3-37778661b567 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}

kinto_http/batch.py:118: KintoBatchException
------------------------------ Captured log call -------------------------------
ERROR    kinto_http.batch:batch.py:86 Batch #0: PUT /buckets/origin - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #1: PUT /buckets/origin/collections/coll - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #2: PUT /buckets/origin/collections/coll/records/7289550e-9ef6-4ae8-b9bf-4f76903d31e6 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #3: PUT /buckets/origin/collections/coll/records/14fa0403-87db-4298-8293-5bc54c4970d1 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #4: PUT /buckets/origin/collections/coll/records/3aa60efb-75a9-448f-a085-59f0147a92a7 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #5: PUT /buckets/origin/collections/coll/records/fd15ce30-7344-470f-b25b-7bd3ce0bd9f3 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #6: PUT /buckets/origin/collections/coll/records/455e62d8-a8a2-4b18-8d67-661d1c51e2bd - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #7: PUT /buckets/origin/collections/coll/records/41af9a36-dab6-42a3-a435-54672af5a845 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #8: PUT /buckets/origin/collections/coll/records/9ef832c3-3f00-4240-9d1b-9aa072d5059c - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #9: PUT /buckets/origin/collections/coll/records/b81cb07d-bc9a-4b44-9c6c-d59c36254658 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #10: PUT /buckets/origin/collections/coll/records/29a4f26c-4031-41b6-b77b-912f412af229 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #11: PUT /buckets/origin/collections/coll/records/0cce390b-3d67-44c1-9da3-37778661b567 - 404
_____________________ FunctionalTest.test_request_batching _____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_request_batching>

    def test_request_batching(self):
        with self.client.batch(bucket="mozilla", collection="fonts") as batch:
            batch.create_bucket()
            batch.create_collection()
            batch.create_record(data={"foo": "bar"}, permissions={"read": ["natim"]})
>           batch.create_record(data={"bar": "baz"}, permissions={"read": ["account:alexis"]})

kinto_http/tests/functional.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/contextlib.py:124: in __exit__
    next(self.gen)
kinto_http/__init__.py:145: in batch
    batch_session.send()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.batch.BatchSession object at 0x7fc8d8835760>

    def send(self):
        self._results = []
        _exceptions = []
        requests = self._build_requests()
        id_request = 0
        for chunk in utils.chunks(requests, self.batch_max_requests):
            kwargs = dict(
                method="POST", endpoint=self.endpoints.get("batch"), payload={"requests": chunk}
            )
            resp, headers = self.session.request(**kwargs)
            for i, response in enumerate(resp["responses"]):
                status_code = response["status"]
    
                level = logging.WARN if status_code < 400 else logging.ERROR
                message = response["body"].get("message", "")
                logger.log(
                    level,
                    "Batch #{}: {} {} - {} {}".format(
                        id_request, chunk[i]["method"], chunk[i]["path"], status_code, message
                    ),
                )
    
                # Full log in DEBUG mode
                logger.debug(
                    "\nBatch #{}: \n\tRequest: {}\n\tResponse: {}\n".format(
                        id_request, utils.json_dumps(chunk[i]), utils.json_dumps(response)
                    )
                )
    
                if not (200 <= status_code < 400):
                    # One of the server response is an error.
                    message = "{0} - {1}".format(status_code, response["body"])
                    exception = KintoException(message)
                    exception.request = RequestDict(chunk[i])
                    exception.response = ResponseDict(response)
                    # Should we ignore 4XX errors?
                    raise_on_4xx = status_code >= 400 and not self._ignore_4xx_errors
                    if raise_on_4xx:
                        _exceptions.append(exception)
                    if status_code >= 500:
                        raise exception
    
                id_request += 1
    
            self._results.append((resp, headers))
    
        if _exceptions:
>           raise KintoBatchException(_exceptions, self._results)
E           kinto_http.exceptions.KintoBatchException: PUT /buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}
E           PUT /buckets/mozilla/collections/fonts - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}
E           PUT /buckets/mozilla/collections/fonts/records/70331747-5981-453b-9715-816ed87b2dc9 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'fonts', 'resource_name': 'collection'}}
E           PUT /buckets/mozilla/collections/fonts/records/283ed09d-4666-4ba1-962b-90b59adb47d7 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'fonts', 'resource_name': 'collection'}}

kinto_http/batch.py:118: KintoBatchException
------------------------------ Captured log call -------------------------------
ERROR    kinto_http.batch:batch.py:86 Batch #0: PUT /buckets/mozilla - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #1: PUT /buckets/mozilla/collections/fonts - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #2: PUT /buckets/mozilla/collections/fonts/records/70331747-5981-453b-9715-816ed87b2dc9 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #3: PUT /buckets/mozilla/collections/fonts/records/283ed09d-4666-4ba1-962b-90b59adb47d7 - 404
_______________ FunctionalTest.test_single_record_can_overwrite ________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_can_overwrite>

    def test_single_record_can_overwrite(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c85aa7f0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493783.628685
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
___________ FunctionalTest.test_single_record_creation_if_not_exists ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_creation_if_not_exists>

    def test_single_record_creation_if_not_exists(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:366: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d8795220>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493784.143776
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________ FunctionalTest.test_single_record_doesnt_overwrite ______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_doesnt_overwrite>

    def test_single_record_doesnt_overwrite(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:352: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c85955b0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493784.648153
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
____________________ FunctionalTest.test_single_record_save ____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_save>

    def test_single_record_save(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:332: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c8560160>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493785.1407192
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________ FunctionalTest.test_updating_data_on_a_collection _______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_updating_data_on_a_collection>

    def test_updating_data_on_a_collection(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc89805b0d0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493785.633727
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_________________ FunctionalTest.test_updating_data_on_a_group _________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_updating_data_on_a_group>

    def test_updating_data_on_a_group(self):
        client = Client(server_url=self.server_url, auth=self.auth, bucket="mozilla")
>       client.create_bucket()

kinto_http/tests/functional.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d86f8070>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493786.1520572
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_____________________ FunctionalTest.test_bucket_creation ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_creation>

    def test_bucket_creation(self):
>       bucket = self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8b0129e80>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493788.1919758
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________ FunctionalTest.test_bucket_creation_if_not_exists _______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_creation_if_not_exists>

    def test_bucket_creation_if_not_exists(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c8697850>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493788.703563
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_____________________ FunctionalTest.test_bucket_deletion ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_deletion>

    def test_bucket_deletion(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c856f460>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493789.238679
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
________________ FunctionalTest.test_bucket_deletion_if_exists _________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_deletion_if_exists>

    def test_bucket_deletion_if_exists(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8a86e7d30>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493789.741419
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
___________________ FunctionalTest.test_bucket_modification ____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_modification>

    def test_bucket_modification(self):
>       bucket = self.client.create_bucket(id="mozilla", data={"version": 1})

kinto_http/tests/functional.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c85ca910>, method = 'put'
endpoint = '/buckets/mozilla', data = {'version': 1}, permissions = None
payload = {'data': {'version': 1}}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{"data": {"version": 1}}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493790.260243
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_____________________ FunctionalTest.test_bucket_retrieval _____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_retrieval>

    def test_bucket_retrieval(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c860b670>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493790.763324
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_________ FunctionalTest.test_bucket_retrieval_fails_when_not_created __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_retrieval_fails_when_not_created>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_______________________ FunctionalTest.test_bucket_save ________________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_save>

    def test_bucket_save(self):
>       self.client.create_bucket(id="mozilla", permissions={"write": ["account:alexis"]})

kinto_http/tests/functional.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8a86b1ac0>, method = 'put'
endpoint = '/buckets/mozilla', data = None
permissions = {'write': ['account:alexis']}
payload = {'permissions': {'write': ['account:alexis']}}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{"permissions": {"write": ["account:alexis"]}}', 'headers': {'Content-Type': '...ion/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493791.8068
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________________ FunctionalTest.test_bucket_sharing ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_bucket_sharing>

    def test_bucket_sharing(self):
        alice_credentials = ("alice", "p4ssw0rd")
>       alice_userid = self.get_user_id(alice_credentials)

kinto_http/tests/functional.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/tests/functional.py:57: in get_user_id
    r = self.create_user(credentials)
kinto_http/tests/functional.py:53: in create_user
    r.raise_for_status()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [400]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 400 Client Error: Bad Request for url: http://localhost:8888/v1/accounts/alice

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_____________________ FunctionalTest.test_buckets_deletion _____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_buckets_deletion>

    def test_buckets_deletion(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c85fb700>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493793.0555542
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
__________ FunctionalTest.test_buckets_deletion_when_no_buckets_exist __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_buckets_deletion_when_no_buckets_exist>

    def test_buckets_deletion_when_no_buckets_exist(self):
>       deleted_buckets = self.client.delete_buckets()

kinto_http/tests/functional.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:398: in delete_buckets
    resp, _ = self.session.request("delete", endpoint, headers=headers)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d8874d90>, method = 'delete'
endpoint = '/buckets', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493793.55558
parsed = ParseResult(scheme='', netloc='', path='/buckets', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: DELETE /v1/buckets - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
____________________ FunctionalTest.test_buckets_retrieval _____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_buckets_retrieval>

    def test_buckets_retrieval(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d86e5e80>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493794.0602071
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_______________ FunctionalTest.test_collection_access_forbidden ________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_access_forbidden>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________________ FunctionalTest.test_collection_creation ____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_creation>

    def test_collection_creation(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:203: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d8822ac0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493795.039559
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
____________ FunctionalTest.test_collection_creation_if_not_exists _____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_creation_if_not_exists>

    def test_collection_creation_if_not_exists(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c860bb20>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493795.535203
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
___________________ FunctionalTest.test_collection_deletion ____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_deletion>

    def test_collection_deletion(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c85ef880>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493796.0349069
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
________ FunctionalTest.test_collection_deletion_can_still_raise_errors ________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_deletion_can_still_raise_errors>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
______________ FunctionalTest.test_collection_deletion_if_exists _______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_deletion_if_exists>

    def test_collection_deletion_if_exists(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d884baf0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493797.0300338
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_____________________ FunctionalTest.test_collection_list ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_list>

    def test_collection_list(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c86b46a0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493797.52503
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
___________________ FunctionalTest.test_collection_not_found ___________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_not_found>

    def test_collection_not_found(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d88c0b80>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493798.028428
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
____________________ FunctionalTest.test_collection_sharing ____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collection_sharing>

    def test_collection_sharing(self):
        alice_credentials = ("alice", "p4ssw0rd")
>       alice_userid = self.get_user_id(alice_credentials)

kinto_http/tests/functional.py:456: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/tests/functional.py:57: in get_user_id
    r = self.create_user(credentials)
kinto_http/tests/functional.py:53: in create_user
    r.raise_for_status()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [400]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 400 Client Error: Bad Request for url: http://localhost:8888/v1/accounts/alice

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
___________________ FunctionalTest.test_collections_deletion ___________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collections_deletion>

    def test_collections_deletion(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d88dd6d0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493799.249773
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______ FunctionalTest.test_collections_deletion_when_no_collections_exist ______

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_collections_deletion_when_no_collections_exist>

    def test_collections_deletion_when_no_collections_exist(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d870c280>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493799.757267
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________________ FunctionalTest.test_group_creation ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_creation>

    def test_group_creation(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d8896220>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493800.260258
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_________ FunctionalTest.test_group_creation_if_bucket_does_not_exist __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_creation_if_bucket_does_not_exist>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_______________ FunctionalTest.test_group_creation_if_not_exists _______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_creation_if_not_exists>

    def test_group_creation_if_not_exists(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8a86e7ac0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493801.255039
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________________ FunctionalTest.test_group_deletion ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_deletion>

    def test_group_deletion(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d88356d0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493801.7702332
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
__________ FunctionalTest.test_group_deletion_can_still_raise_errors ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_deletion_can_still_raise_errors>

    def tearDown(self):
        # Delete all the created objects
        flush_url = urljoin(self.server_url, "/__flush__")
        resp = requests.post(flush_url)
>       resp.raise_for_status()

kinto_http/tests/functional.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [404]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8888/v1/__flush__

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
_________________ FunctionalTest.test_group_deletion_if_exists _________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_deletion_if_exists>

    def test_group_deletion_if_exists(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d86f63d0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493802.77742
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
________________________ FunctionalTest.test_group_list ________________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_list>

    def test_group_list(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c85aa5b0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493803.2771351
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_______________________ FunctionalTest.test_group_update _______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_group_update>

    def test_group_update(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d87f6040>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493803.78652
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_____________________ FunctionalTest.test_groups_deletion ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_groups_deletion>

    def test_groups_deletion(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d88051c0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493804.30822
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
___________ FunctionalTest.test_groups_deletion_when_no_groups_exist ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_groups_deletion_when_no_groups_exist>

    def test_groups_deletion_when_no_groups_exist(self):
>       self.client.create_bucket(id="mozilla")

kinto_http/tests/functional.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c8613fd0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493804.8003242
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_________________ FunctionalTest.test_multiple_record_deletion _________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_multiple_record_deletion>

    def test_multiple_record_deletion(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:410: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8a870dd00>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493805.301053
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
___________________ FunctionalTest.test_one_record_deletion ____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_one_record_deletion>

    def test_one_record_deletion(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c8457970>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493805.789197
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
__________________ FunctionalTest.test_patch_record_jsonpatch __________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_patch_record_jsonpatch>

    def test_patch_record_jsonpatch(self):
>       self.client.create_bucket(id="b1")

kinto_http/tests/functional.py:504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d86f84c0>, method = 'put'
endpoint = '/buckets/b1', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493806.31306
parsed = ParseResult(scheme='', netloc='', path='/buckets/b1', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/b1'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/b1 - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________ FunctionalTest.test_record_creation_and_retrieval _______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_record_creation_and_retrieval>

    def test_record_creation_and_retrieval(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d8813340>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493806.819116
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
________________ FunctionalTest.test_record_deletion_if_exists _________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_record_deletion_if_exists>

    def test_record_deletion_if_exists(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:398: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d87f2190>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493807.319568
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________________ FunctionalTest.test_record_sharing ______________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_record_sharing>

    def test_record_sharing(self):
        alice_credentials = ("alice", "p4ssw0rd")
>       alice_userid = self.get_user_id(alice_credentials)

kinto_http/tests/functional.py:469: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/tests/functional.py:57: in get_user_id
    r = self.create_user(credentials)
kinto_http/tests/functional.py:53: in create_user
    r.raise_for_status()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [400]>

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""
    
        http_error_msg = ''
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = self.reason.decode('iso-8859-1')
        else:
            reason = self.reason
    
        if 400 <= self.status_code < 500:
            http_error_msg = u'%s Client Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        elif 500 <= self.status_code < 600:
            http_error_msg = u'%s Server Error: %s for url: %s' % (self.status_code, reason, self.url)
    
        if http_error_msg:
>           raise HTTPError(http_error_msg, response=self)
E           requests.exceptions.HTTPError: 400 Client Error: Bad Request for url: http://localhost:8888/v1/accounts/alice

.venv/lib/python3.9/site-packages/requests/models.py:943: HTTPError
__________ FunctionalTest.test_records_deletion_when_no_records_exist __________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_deletion_when_no_records_exist>

    def test_records_deletion_when_no_records_exist(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:420: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d884d100>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493808.570177
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_______________ FunctionalTest.test_records_generator_retrieval ________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_generator_retrieval>

    def test_records_generator_retrieval(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c8597040>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493809.064797
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
__________________ FunctionalTest.test_records_list_retrieval __________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_list_retrieval>

    def test_records_list_retrieval(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c8673b20>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493809.582399
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_____________ FunctionalTest.test_records_paginated_list_retrieval _____________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_paginated_list_retrieval>

    def test_records_paginated_list_retrieval(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c867df40>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493810.072833
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_______________ FunctionalTest.test_records_timestamp_retrieval ________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_records_timestamp_retrieval>

    def test_records_timestamp_retrieval(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8a86e7f10>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493810.589487
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_______________________ FunctionalTest.test_replication ________________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_replication>

    def test_replication(self):
        # First, create a few records on the first kinto collection.
        with self.client.batch(bucket="origin", collection="coll") as batch:
            batch.create_bucket()
            batch.create_collection()
    
            for n in range(10):
>               batch.create_record(data={"foo": "bar", "n": n})

kinto_http/tests/functional.py:526: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/contextlib.py:124: in __exit__
    next(self.gen)
kinto_http/__init__.py:145: in batch
    batch_session.send()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.batch.BatchSession object at 0x7fc8c8595b80>

    def send(self):
        self._results = []
        _exceptions = []
        requests = self._build_requests()
        id_request = 0
        for chunk in utils.chunks(requests, self.batch_max_requests):
            kwargs = dict(
                method="POST", endpoint=self.endpoints.get("batch"), payload={"requests": chunk}
            )
            resp, headers = self.session.request(**kwargs)
            for i, response in enumerate(resp["responses"]):
                status_code = response["status"]
    
                level = logging.WARN if status_code < 400 else logging.ERROR
                message = response["body"].get("message", "")
                logger.log(
                    level,
                    "Batch #{}: {} {} - {} {}".format(
                        id_request, chunk[i]["method"], chunk[i]["path"], status_code, message
                    ),
                )
    
                # Full log in DEBUG mode
                logger.debug(
                    "\nBatch #{}: \n\tRequest: {}\n\tResponse: {}\n".format(
                        id_request, utils.json_dumps(chunk[i]), utils.json_dumps(response)
                    )
                )
    
                if not (200 <= status_code < 400):
                    # One of the server response is an error.
                    message = "{0} - {1}".format(status_code, response["body"])
                    exception = KintoException(message)
                    exception.request = RequestDict(chunk[i])
                    exception.response = ResponseDict(response)
                    # Should we ignore 4XX errors?
                    raise_on_4xx = status_code >= 400 and not self._ignore_4xx_errors
                    if raise_on_4xx:
                        _exceptions.append(exception)
                    if status_code >= 500:
                        raise exception
    
                id_request += 1
    
            self._results.append((resp, headers))
    
        if _exceptions:
>           raise KintoBatchException(_exceptions, self._results)
E           kinto_http.exceptions.KintoBatchException: PUT /buckets/origin - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}
E           PUT /buckets/origin/collections/coll - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}
E           PUT /buckets/origin/collections/coll/records/3f3adc05-d518-46a1-bcc6-c9702581e848 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/dd188300-eb6a-4d13-a02d-1f758ba2411c - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/75f531a7-c1db-47cd-b6ce-6096aa1ff61c - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/69e65fcd-7fc5-4c69-b81b-692a01bcc23a - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/48d58f1a-7677-45db-8140-e73867815660 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/3b8b18fa-584c-45c9-b8c8-71e5373173f4 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/6edcc7ac-bfd4-4599-b8bd-10bea13a1c00 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/e975ef31-93b8-4ed2-adbe-52974d6d83bb - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/55e68de1-3b5d-410a-92b9-c79188f705b0 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}
E           PUT /buckets/origin/collections/coll/records/6454571c-40ff-40aa-9fd9-0202ccd517b0 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'coll', 'resource_name': 'collection'}}

kinto_http/batch.py:118: KintoBatchException
------------------------------ Captured log call -------------------------------
ERROR    kinto_http.batch:batch.py:86 Batch #0: PUT /buckets/origin - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #1: PUT /buckets/origin/collections/coll - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #2: PUT /buckets/origin/collections/coll/records/3f3adc05-d518-46a1-bcc6-c9702581e848 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #3: PUT /buckets/origin/collections/coll/records/dd188300-eb6a-4d13-a02d-1f758ba2411c - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #4: PUT /buckets/origin/collections/coll/records/75f531a7-c1db-47cd-b6ce-6096aa1ff61c - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #5: PUT /buckets/origin/collections/coll/records/69e65fcd-7fc5-4c69-b81b-692a01bcc23a - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #6: PUT /buckets/origin/collections/coll/records/48d58f1a-7677-45db-8140-e73867815660 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #7: PUT /buckets/origin/collections/coll/records/3b8b18fa-584c-45c9-b8c8-71e5373173f4 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #8: PUT /buckets/origin/collections/coll/records/6edcc7ac-bfd4-4599-b8bd-10bea13a1c00 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #9: PUT /buckets/origin/collections/coll/records/e975ef31-93b8-4ed2-adbe-52974d6d83bb - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #10: PUT /buckets/origin/collections/coll/records/55e68de1-3b5d-410a-92b9-c79188f705b0 - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #11: PUT /buckets/origin/collections/coll/records/6454571c-40ff-40aa-9fd9-0202ccd517b0 - 404
_____________________ FunctionalTest.test_request_batching _____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_request_batching>

    def test_request_batching(self):
        with self.client.batch(bucket="mozilla", collection="fonts") as batch:
            batch.create_bucket()
            batch.create_collection()
            batch.create_record(data={"foo": "bar"}, permissions={"read": ["natim"]})
>           batch.create_record(data={"bar": "baz"}, permissions={"read": ["account:alexis"]})

kinto_http/tests/functional.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/contextlib.py:124: in __exit__
    next(self.gen)
kinto_http/__init__.py:145: in batch
    batch_session.send()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.batch.BatchSession object at 0x7fc8c865a760>

    def send(self):
        self._results = []
        _exceptions = []
        requests = self._build_requests()
        id_request = 0
        for chunk in utils.chunks(requests, self.batch_max_requests):
            kwargs = dict(
                method="POST", endpoint=self.endpoints.get("batch"), payload={"requests": chunk}
            )
            resp, headers = self.session.request(**kwargs)
            for i, response in enumerate(resp["responses"]):
                status_code = response["status"]
    
                level = logging.WARN if status_code < 400 else logging.ERROR
                message = response["body"].get("message", "")
                logger.log(
                    level,
                    "Batch #{}: {} {} - {} {}".format(
                        id_request, chunk[i]["method"], chunk[i]["path"], status_code, message
                    ),
                )
    
                # Full log in DEBUG mode
                logger.debug(
                    "\nBatch #{}: \n\tRequest: {}\n\tResponse: {}\n".format(
                        id_request, utils.json_dumps(chunk[i]), utils.json_dumps(response)
                    )
                )
    
                if not (200 <= status_code < 400):
                    # One of the server response is an error.
                    message = "{0} - {1}".format(status_code, response["body"])
                    exception = KintoException(message)
                    exception.request = RequestDict(chunk[i])
                    exception.response = ResponseDict(response)
                    # Should we ignore 4XX errors?
                    raise_on_4xx = status_code >= 400 and not self._ignore_4xx_errors
                    if raise_on_4xx:
                        _exceptions.append(exception)
                    if status_code >= 500:
                        raise exception
    
                id_request += 1
    
            self._results.append((resp, headers))
    
        if _exceptions:
>           raise KintoBatchException(_exceptions, self._results)
E           kinto_http.exceptions.KintoBatchException: PUT /buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}
E           PUT /buckets/mozilla/collections/fonts - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}
E           PUT /buckets/mozilla/collections/fonts/records/622c7024-26ad-452e-aa5f-263de86f852f - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'fonts', 'resource_name': 'collection'}}
E           PUT /buckets/mozilla/collections/fonts/records/76290638-44f2-4209-b090-27d88104cfb1 - 404 404 - {'code': 404, 'errno': 111, 'error': 'Not Found', 'details': {'id': 'fonts', 'resource_name': 'collection'}}

kinto_http/batch.py:118: KintoBatchException
------------------------------ Captured log call -------------------------------
ERROR    kinto_http.batch:batch.py:86 Batch #0: PUT /buckets/mozilla - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #1: PUT /buckets/mozilla/collections/fonts - 403 This user cannot access this resource.
ERROR    kinto_http.batch:batch.py:86 Batch #2: PUT /buckets/mozilla/collections/fonts/records/622c7024-26ad-452e-aa5f-263de86f852f - 404 
ERROR    kinto_http.batch:batch.py:86 Batch #3: PUT /buckets/mozilla/collections/fonts/records/76290638-44f2-4209-b090-27d88104cfb1 - 404
_______________ FunctionalTest.test_single_record_can_overwrite ________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_can_overwrite>

    def test_single_record_can_overwrite(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d8805370>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493812.1587908
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
___________ FunctionalTest.test_single_record_creation_if_not_exists ___________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_creation_if_not_exists>

    def test_single_record_creation_if_not_exists(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:366: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d8705fd0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493812.675483
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________ FunctionalTest.test_single_record_doesnt_overwrite ______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_doesnt_overwrite>

    def test_single_record_doesnt_overwrite(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:352: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c85fcca0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493813.172276
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
____________________ FunctionalTest.test_single_record_save ____________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_single_record_save>

    def test_single_record_save(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:332: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d8795310>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493813.681948
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
______________ FunctionalTest.test_updating_data_on_a_collection _______________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_updating_data_on_a_collection>

    def test_updating_data_on_a_collection(self):
        client = Client(
            server_url=self.server_url, auth=self.auth, bucket="mozilla", collection="payments"
        )
>       client.create_bucket()

kinto_http/tests/functional.py:447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8d88ba640>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493814.1852748
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
_________________ FunctionalTest.test_updating_data_on_a_group _________________

self = <kinto_http.tests.functional.FunctionalTest testMethod=test_updating_data_on_a_group>

    def test_updating_data_on_a_group(self):
        client = Client(server_url=self.server_url, auth=self.auth, bucket="mozilla")
>       client.create_bucket()

kinto_http/tests/functional.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
kinto_http/__init__.py:302: in create_bucket
    resp, _ = self.session.request(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <kinto_http.session.Session object at 0x7fc8c867baf0>, method = 'put'
endpoint = '/buckets/mozilla', data = None, permissions = None, payload = {}
kwargs = {'auth': ('user', 'p4ssw0rd'), 'data': '{}', 'headers': {'Content-Type': 'application/json', 'If-None-Match': '*', 'User-Agent': 'kinto_http/10.8.0.dev0 requests/2.25.1 python/3.9.0'}, 'timeout': None}
current_time = 1615493814.705764
parsed = ParseResult(scheme='', netloc='', path='/buckets/mozilla', params='', query='', fragment='')
actual_url = 'http://localhost:8888/v1/buckets/mozilla'

    def request(self, method, endpoint, data=None, permissions=None, payload=None, **kwargs):
        current_time = time.time()
        if self.backoff and self.backoff > current_time:
            seconds = int(self.backoff - current_time)
            raise BackoffException("Retry after {} seconds".format(seconds), seconds)
    
        parsed = urlparse(endpoint)
        if not parsed.scheme:
            actual_url = utils.urljoin(self.server_url, endpoint)
        else:
            actual_url = endpoint
    
        if self.timeout is not False:
            kwargs.setdefault("timeout", self.timeout)
    
        if self.auth is not None:
            kwargs.setdefault("auth", self.auth)
    
        if kwargs.get("params") is not None:
            params = dict()
            for key, value in kwargs["params"].items():
                if key.startswith("in_") or key.startswith("exclude_"):
                    params[key] = ",".join(value)
                elif isinstance(value, str):
                    params[key] = value
                else:
                    params[key] = json.dumps(value)
            kwargs["params"] = params
    
        overridden_headers = kwargs.get("headers") or {}
    
        # Set the default User-Agent if not already defined.
        kwargs["headers"] = {"User-Agent": USER_AGENT, **self.headers, **overridden_headers}
    
        payload = payload or {}
        if data is not None:
            payload["data"] = data
        if permissions is not None:
            if hasattr(permissions, "as_dict"):
                permissions = permissions.as_dict()
            payload["permissions"] = permissions
        if method not in ("get", "head"):
            if "files" in kwargs:
                kwargs.setdefault("data", payload)
            else:
                kwargs.setdefault("data", utils.json_dumps(payload))
                kwargs["headers"].setdefault("Content-Type", "application/json")
    
        retry = self.nb_retry
        while retry >= 0:
            resp = requests.request(method, actual_url, **kwargs)
            backoff_seconds = resp.headers.get("Backoff")
            if backoff_seconds:
                self.backoff = time.time() + int(backoff_seconds)
            else:
                self.backoff = None
    
            retry = retry - 1
            if 200 <= resp.status_code < 400:
                # Success
                break
            else:
                if retry >= 0 and (resp.status_code >= 500 or resp.status_code == 409):
                    # Wait and try again.
                    # If not forced, use retry-after header and wait.
                    if self.retry_after is None:
                        retry_after = int(resp.headers.get("Retry-After", 0))
                    else:
                        retry_after = self.retry_after
                    time.sleep(retry_after)
                    continue
    
                # Retries exhausted, raise expection.
                try:
                    message = "{0} - {1}".format(resp.status_code, resp.json())
                except ValueError:
                    # In case the response is not JSON, fallback to text.
                    message = "{0} - {1}".format(resp.status_code, resp.text)
                exception = KintoException(message)
                exception.request = resp.request
                exception.response = resp
>               raise exception
E               kinto_http.exceptions.KintoException: PUT /v1/buckets/mozilla - 403 403 - {'code': 403, 'errno': 121, 'error': 'Forbidden', 'message': 'This user cannot access this resource.'}

kinto_http/session.py:143: KintoException
=========================== short test summary info ============================
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_creation
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_creation_if_not_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_deletion_if_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_modification
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_retrieval_fails_when_not_created
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_save - kin...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_sharing - ...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_buckets_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_buckets_deletion_when_no_buckets_exist
FAILED kinto_http/tests/functional.py::FunctionalTest::test_buckets_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_access_forbidden
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_creation
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_creation_if_not_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_deletion_can_still_raise_errors
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_deletion_if_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_list
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_not_found
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_sharing
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collections_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collections_deletion_when_no_collections_exist
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_creation - ...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_creation_if_bucket_does_not_exist
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_creation_if_not_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_deletion - ...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_deletion_can_still_raise_errors
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_deletion_if_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_list - kint...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_update - ki...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_groups_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_groups_deletion_when_no_groups_exist
FAILED kinto_http/tests/functional.py::FunctionalTest::test_multiple_record_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_one_record_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_patch_record_jsonpatch
FAILED kinto_http/tests/functional.py::FunctionalTest::test_record_creation_and_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_record_deletion_if_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_record_sharing - ...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_records_deletion_when_no_records_exist
FAILED kinto_http/tests/functional.py::FunctionalTest::test_records_generator_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_records_list_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_records_paginated_list_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_records_timestamp_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_replication - kin...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_request_batching
FAILED kinto_http/tests/functional.py::FunctionalTest::test_single_record_can_overwrite
FAILED kinto_http/tests/functional.py::FunctionalTest::test_single_record_creation_if_not_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_single_record_doesnt_overwrite
FAILED kinto_http/tests/functional.py::FunctionalTest::test_single_record_save
FAILED kinto_http/tests/functional.py::FunctionalTest::test_updating_data_on_a_collection
FAILED kinto_http/tests/functional.py::FunctionalTest::test_updating_data_on_a_group
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_creation
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_creation_if_not_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_deletion_if_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_modification
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_retrieval_fails_when_not_created
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_save - kin...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_bucket_sharing - ...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_buckets_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_buckets_deletion_when_no_buckets_exist
FAILED kinto_http/tests/functional.py::FunctionalTest::test_buckets_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_access_forbidden
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_creation
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_creation_if_not_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_deletion_can_still_raise_errors
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_deletion_if_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_list
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_not_found
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collection_sharing
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collections_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_collections_deletion_when_no_collections_exist
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_creation - ...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_creation_if_bucket_does_not_exist
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_creation_if_not_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_deletion - ...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_deletion_can_still_raise_errors
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_deletion_if_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_list - kint...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_group_update - ki...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_groups_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_groups_deletion_when_no_groups_exist
FAILED kinto_http/tests/functional.py::FunctionalTest::test_multiple_record_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_one_record_deletion
FAILED kinto_http/tests/functional.py::FunctionalTest::test_patch_record_jsonpatch
FAILED kinto_http/tests/functional.py::FunctionalTest::test_record_creation_and_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_record_deletion_if_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_record_sharing - ...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_records_deletion_when_no_records_exist
FAILED kinto_http/tests/functional.py::FunctionalTest::test_records_generator_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_records_list_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_records_paginated_list_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_records_timestamp_retrieval
FAILED kinto_http/tests/functional.py::FunctionalTest::test_replication - kin...
FAILED kinto_http/tests/functional.py::FunctionalTest::test_request_batching
FAILED kinto_http/tests/functional.py::FunctionalTest::test_single_record_can_overwrite
FAILED kinto_http/tests/functional.py::FunctionalTest::test_single_record_creation_if_not_exists
FAILED kinto_http/tests/functional.py::FunctionalTest::test_single_record_doesnt_overwrite
FAILED kinto_http/tests/functional.py::FunctionalTest::test_single_record_save
FAILED kinto_http/tests/functional.py::FunctionalTest::test_updating_data_on_a_collection
FAILED kinto_http/tests/functional.py::FunctionalTest::test_updating_data_on_a_group
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_creation - ...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_creation_if_not_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_deletion - ...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_deletion_if_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_modification
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_save - requ...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_sharing - r...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_buckets_deletion
ERROR kinto_http/tests/functional.py::FunctionalTest::test_buckets_deletion_when_no_buckets_exist
ERROR kinto_http/tests/functional.py::FunctionalTest::test_buckets_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_creation
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_creation_if_not_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_deletion
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_deletion_if_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_list - ...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_not_found
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_sharing
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collections_deletion
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collections_deletion_when_no_collections_exist
ERROR kinto_http/tests/functional.py::FunctionalTest::test_group_creation - r...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_group_creation_if_not_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_group_deletion - r...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_group_deletion_if_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_group_list - reque...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_group_update - req...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_groups_deletion - ...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_groups_deletion_when_no_groups_exist
ERROR kinto_http/tests/functional.py::FunctionalTest::test_multiple_record_deletion
ERROR kinto_http/tests/functional.py::FunctionalTest::test_one_record_deletion
ERROR kinto_http/tests/functional.py::FunctionalTest::test_patch_record_jsonpatch
ERROR kinto_http/tests/functional.py::FunctionalTest::test_record_creation_and_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_record_deletion_if_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_record_sharing - r...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_records_deletion_when_no_records_exist
ERROR kinto_http/tests/functional.py::FunctionalTest::test_records_generator_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_records_list_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_records_paginated_list_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_records_timestamp_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_replication - requ...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_request_batching
ERROR kinto_http/tests/functional.py::FunctionalTest::test_single_record_can_overwrite
ERROR kinto_http/tests/functional.py::FunctionalTest::test_single_record_creation_if_not_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_single_record_doesnt_overwrite
ERROR kinto_http/tests/functional.py::FunctionalTest::test_single_record_save
ERROR kinto_http/tests/functional.py::FunctionalTest::test_updating_data_on_a_collection
ERROR kinto_http/tests/functional.py::FunctionalTest::test_updating_data_on_a_group
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_creation - ...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_creation_if_not_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_deletion - ...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_deletion_if_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_modification
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_save - requ...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_bucket_sharing - r...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_buckets_deletion
ERROR kinto_http/tests/functional.py::FunctionalTest::test_buckets_deletion_when_no_buckets_exist
ERROR kinto_http/tests/functional.py::FunctionalTest::test_buckets_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_creation
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_creation_if_not_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_deletion
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_deletion_if_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_list - ...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_not_found
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collection_sharing
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collections_deletion
ERROR kinto_http/tests/functional.py::FunctionalTest::test_collections_deletion_when_no_collections_exist
ERROR kinto_http/tests/functional.py::FunctionalTest::test_group_creation - r...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_group_creation_if_not_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_group_deletion - r...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_group_deletion_if_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_group_list - reque...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_group_update - req...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_groups_deletion - ...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_groups_deletion_when_no_groups_exist
ERROR kinto_http/tests/functional.py::FunctionalTest::test_multiple_record_deletion
ERROR kinto_http/tests/functional.py::FunctionalTest::test_one_record_deletion
ERROR kinto_http/tests/functional.py::FunctionalTest::test_patch_record_jsonpatch
ERROR kinto_http/tests/functional.py::FunctionalTest::test_record_creation_and_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_record_deletion_if_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_record_sharing - r...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_records_deletion_when_no_records_exist
ERROR kinto_http/tests/functional.py::FunctionalTest::test_records_generator_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_records_list_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_records_paginated_list_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_records_timestamp_retrieval
ERROR kinto_http/tests/functional.py::FunctionalTest::test_replication - requ...
ERROR kinto_http/tests/functional.py::FunctionalTest::test_request_batching
ERROR kinto_http/tests/functional.py::FunctionalTest::test_single_record_can_overwrite
ERROR kinto_http/tests/functional.py::FunctionalTest::test_single_record_creation_if_not_exists
ERROR kinto_http/tests/functional.py::FunctionalTest::test_single_record_doesnt_overwrite
ERROR kinto_http/tests/functional.py::FunctionalTest::test_single_record_save
ERROR kinto_http/tests/functional.py::FunctionalTest::test_updating_data_on_a_collection
ERROR kinto_http/tests/functional.py::FunctionalTest::test_updating_data_on_a_group
================= 104 failed, 229 passed, 94 errors in 56.42s ==================
################################ LOOPONFAILING #################################
kinto_http/tests/functional.py::FunctionalTest::test_bucket_creation
kinto_http/tests/functional.py::FunctionalTest::test_bucket_creation_if_not_exists
kinto_http/tests/functional.py::FunctionalTest::test_bucket_deletion
kinto_http/tests/functional.py::FunctionalTest::test_bucket_deletion_if_exists
kinto_http/tests/functional.py::FunctionalTest::test_bucket_modification
kinto_http/tests/functional.py::FunctionalTest::test_bucket_retrieval
kinto_http/tests/functional.py::FunctionalTest::test_bucket_retrieval_fails_when_not_created
kinto_http/tests/functional.py::FunctionalTest::test_bucket_save
kinto_http/tests/functional.py::FunctionalTest::test_bucket_sharing
kinto_http/tests/functional.py::FunctionalTest::test_buckets_deletion
kinto_http/tests/functional.py::FunctionalTest::test_buckets_deletion_when_no_buckets_exist
kinto_http/tests/functional.py::FunctionalTest::test_buckets_retrieval
kinto_http/tests/functional.py::FunctionalTest::test_collection_access_forbidden
kinto_http/tests/functional.py::FunctionalTest::test_collection_creation
kinto_http/tests/functional.py::FunctionalTest::test_collection_creation_if_not_exists
kinto_http/tests/functional.py::FunctionalTest::test_collection_deletion
kinto_http/tests/functional.py::FunctionalTest::test_collection_deletion_can_still_raise_errors
kinto_http/tests/functional.py::FunctionalTest::test_collection_deletion_if_exists
kinto_http/tests/functional.py::FunctionalTest::test_collection_list
kinto_http/tests/functional.py::FunctionalTest::test_collection_not_found
kinto_http/tests/functional.py::FunctionalTest::test_collection_sharing
kinto_http/tests/functional.py::FunctionalTest::test_collections_deletion
kinto_http/tests/functional.py::FunctionalTest::test_collections_deletion_when_no_collections_exist
kinto_http/tests/functional.py::FunctionalTest::test_group_creation
kinto_http/tests/functional.py::FunctionalTest::test_group_creation_if_bucket_does_not_exist
kinto_http/tests/functional.py::FunctionalTest::test_group_creation_if_not_exists
kinto_http/tests/functional.py::FunctionalTest::test_group_deletion
kinto_http/tests/functional.py::FunctionalTest::test_group_deletion_can_still_raise_errors
kinto_http/tests/functional.py::FunctionalTest::test_group_deletion_if_exists
kinto_http/tests/functional.py::FunctionalTest::test_group_list
kinto_http/tests/functional.py::FunctionalTest::test_group_update
kinto_http/tests/functional.py::FunctionalTest::test_groups_deletion
kinto_http/tests/functional.py::FunctionalTest::test_groups_deletion_when_no_groups_exist
kinto_http/tests/functional.py::FunctionalTest::test_multiple_record_deletion
kinto_http/tests/functional.py::FunctionalTest::test_one_record_deletion
kinto_http/tests/functional.py::FunctionalTest::test_patch_record_jsonpatch
kinto_http/tests/functional.py::FunctionalTest::test_record_creation_and_retrieval
kinto_http/tests/functional.py::FunctionalTest::test_record_deletion_if_exists
kinto_http/tests/functional.py::FunctionalTest::test_record_sharing
kinto_http/tests/functional.py::FunctionalTest::test_records_deletion_when_no_records_exist
kinto_http/tests/functional.py::FunctionalTest::test_records_generator_retrieval
kinto_http/tests/functional.py::FunctionalTest::test_records_list_retrieval
kinto_http/tests/functional.py::FunctionalTest::test_records_paginated_list_retrieval
kinto_http/tests/functional.py::FunctionalTest::test_records_timestamp_retrieval
kinto_http/tests/functional.py::FunctionalTest::test_replication
kinto_http/tests/functional.py::FunctionalTest::test_request_batching
kinto_http/tests/functional.py::FunctionalTest::test_single_record_can_overwrite
kinto_http/tests/functional.py::FunctionalTest::test_single_record_creation_if_not_exists
kinto_http/tests/functional.py::FunctionalTest::test_single_record_doesnt_overwrite
kinto_http/tests/functional.py::FunctionalTest::test_single_record_save
kinto_http/tests/functional.py::FunctionalTest::test_updating_data_on_a_collection
kinto_http/tests/functional.py::FunctionalTest::test_updating_data_on_a_group
############################# waiting for changes ##############################
### Watching:   /Users/jeffryhidayat/Documents/kinto2/kinto-http.py
